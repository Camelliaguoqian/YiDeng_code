·C语言
·c++
·指针和对象
·class
·构造函数
1）类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。
构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。

2）默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值

3）类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。
析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。

4）构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。特别的一个类可以有多个构造函数 ，可根据其参数个数的不同或参数类型的不同来区分它们 即构造函数的重载。
　　特点：
　　1.构造函数的命名必须和类名完全相同。在java中普通函数可以和构造函数同名，但是必须带有返回值；
　　2.构造函数的功能主要用于在类的对象创建时定义初始化的状态。它没有返回值，也不能用void来修饰。这就保证了它不仅什么也不用自动返回，而且根本不能有任何选择。而其他方法都有返回值，即使是void返回值。尽管方法体本身不会自动返回什么，但仍然可以让它返回一些东西，而这些东西可能是不安全的；
　　3.构造函数不能被直接调用，必须通过new运算符在创建对象时才会自动调用；而一般的方法是在程序执行到它的时候被调用的；
　　4.当定义一个类的时候，通常情况下都会显示该类的构造函数，并在函数中指定初始化的工作也可省略，不过Java编译器会提供一个默认的构造函数.此默认构造函数是不带参数的。而一般的方法不存在这一特点；
　　5.当一个类只定义了私有的构造函数，将无法通过new关键字来创建其对象，当一个类没有定义任何构造函数，C#编译器会为其自动生成一个默认的无参的构造函数。
　　6.构造函数有回滚的效果，构造函数抛出异常时，构造的是一个不完整对象，会回滚，将此不完整对象的成员释放(c++)。


=======
js中 面向对象
【http://caibaojian.com/javascript-object-5.html】
·对象
·工厂模式
·构造函数
·原型
·原型链
·this
·继承
==
备注：
JavaScript中没有类,只有new运算来模拟类,构造函数无从谈起
如果使用
var xxx = function(){}
这种形式你就称之为类,那么你不对它实例化(new)它也会自己运行(构造函数)的

==
·关于构造函数，如果你暂时不能够理解new的具体实现，就先记住下面这几个结论吧。
与普通函数相比，构造函数并没有任何特别的地方，首字母大写只是我们约定的小规定，用于区分普通函数；
new关键字让构造函数具有了与普通函数不同的许多特点，而new的过程中，执行了如下过程：
·声明一个中间对象；
·将该中间对象的原型指向构造函数的原型；
·将构造函数的this，指向该中间对象；
·返回该中间对象，即返回实例对象。

==
·我们创建的每一个函数，都可以有一个prototype属性，该属性指向一个对象。这个对象，就是我们这里说的原型。
·当我们在创建对象时，可以根据自己的需求，选择性的将一些属性和方法通过prototype属性，挂载在原型对象上。而每一个new出来的实例，都有一个__proto__属性，该属性指向构造函数的原型对象，通过这个属性，让实例对象也能够访问原型对象上的方法。因此，当所有的实例都能够通过__proto__访问到原型对象时，原型对象的方法与属性就变成了共有方法与属性。

·构造函数的prototype与所有实例对象的__proto__都指向原型对象。而原型对象与实例对象的constructor都指向构造函数。

·实例对象实际上对前面我们所说的中间对象的复制，而中间对象中的属性与方法都在构造函数中添加。
于是根据构造函数与原型的特性，我们就可以将在构造函数中，通过this声明的属性与方法称为私有变量与方法，它们被当前被某一个实例对象所独有。
而通过原型声明的属性与方法，我们可以称之为共有属性与方法，它们可以被所有的实例对象访问。

·当我们访问实例对象中的属性或者方法时，会优先访问实例对象自身的属性和方法。


·通过in来判断，一个对象是否拥有某一个属性/方法，无论是该属性/方法存在与实例对象还是原型对象。
（tips: 
in的这种特性最常用的场景之一，就是判断当前页面是否在移动端打开。
isMobile = 'ontouchstart' in document;
// 很多人喜欢用浏览器UA的方式来判断，但并不是很好的方式）


===
·原型链
原型对象其实也是普通的对象。几乎所有的对象都可能是原型对象，也可能是实例对象，而且还可以同时是原型对象与实例对象。
这样的一个对象，正是构成原型链的一个节点。
因此理解了原型，那么原型链并不是一个多么复杂的概念。

原型链的访问，其实跟作用域链有很大的相似之处，他们都是一次单向的查找过程。因此实例对象能够通过原型链，访问到处于原型链上对象的所有属性与方法。
例子：所有的函数都有一个叫做toString的方法，其中foo是Function对象的实例。而Function的原型对象同时又是Object的实例。这样就构成了一条原型链。这也是foo最终能够访问到处于Object对象上的toString方法的原因。

==
·构造函数的继承
在上面我们已经理解了构造函数的本质，它其实是在new内部实现的一个复制过程。
而我们在继承时想要的，就是想父级构造函数中的操作在子级的构造函数中重现一遍即可。我们可以通过call方法来达到目的。
·原型的继承
则只需要将子级的原型对象设置为父级的一个实例，加入到原型链中即可。


扩展阅读
【https://www.jianshu.com/p/cd3fee40ef59】
前端基础进阶（一）：内存空间详细图解
前端基础进阶（二）：执行上下文详细图解
前端基础进阶（三）：变量对象详解
前端基础进阶（四）：详细图解作用域链与闭包
前端基础进阶（五）：全方位解读this
前端基础进阶（六）：在chrome开发者工具中观察函数调用栈、作用域链与闭包
前端基础进阶（七）：函数与函数式编程
前端基础进阶（八）：深入详解函数的柯里化
前端基础进阶（九）：详解面向对象、构造函数、原型与原型链
前端基础进阶（十）：面向对象实战之封装拖拽对象
前端基础进阶（十一）：详细图解jQuery对象，以及如何扩展jQuery插件
前端基础进阶（十二）：深入核心，详解事件循环机制
前端基础进阶（十三）：Promise使用详解
前端基础进阶（十四）：ES6基础知识合集
前端基础进阶（十五）：详解 ES6 Modules
我想这将是最有价值的react入门与进阶教程







